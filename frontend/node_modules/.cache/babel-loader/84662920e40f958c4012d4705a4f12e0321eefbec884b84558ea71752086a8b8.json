{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { applyLocalizedDigits, cleanLeadingZeros, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, removeLocalizedDigits } from \"./useField.utils.js\";\nconst expandFormat = _ref => {\n  let {\n    utils,\n    format\n  } = _ref;\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the component.');\n    }\n  }\n  return nextFormat;\n};\nconst getEscapedPartsFromFormat = _ref2 => {\n  let {\n    utils,\n    expandedFormat\n  } = _ref2;\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nconst getSectionPlaceholder = (utils, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(undefined, 'default'), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nconst createSection = _ref3 => {\n  let {\n    utils,\n    date,\n    shouldRespectLeadingZeros,\n    localeText,\n    localizedDigits,\n    now,\n    token,\n    startSeparator\n  } = _ref3;\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n  const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = utils.isValid(date);\n  let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n  let maxLength = null;\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxLength' property on it's adapter`);\n      }\n      maxLength = sectionConfig.maxLength;\n      if (isValidDate) {\n        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n  return _extends({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\nconst buildSections = parameters => {\n  const {\n    utils,\n    expandedFormat,\n    escapedParts\n  } = parameters;\n  const now = utils.date(undefined);\n  const sections = [];\n  let startSeparator = '';\n\n  // This RegExp tests if the beginning of a string corresponds to a supported token\n  const validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n  let i = 0;\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];\n\n    // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection(_extends({}, parameters, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n      i += firstWordInFormat.length;\n    }\n    // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i];\n\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n          sections[sections.length - 1].isEndFormatSeparator = true;\n        }\n      }\n      i += 1;\n    }\n  }\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n  return sections;\n};\nconst postProcessSections = _ref4 => {\n  let {\n    isRtl,\n    formatDensity,\n    sections\n  } = _ref4;\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\nexport const buildSectionsFromFormat = parameters => {\n  let expandedFormat = expandFormat(parameters);\n  if (parameters.isRtl && parameters.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n  const escapedParts = getEscapedPartsFromFormat(_extends({}, parameters, {\n    expandedFormat\n  }));\n  const sections = buildSections(_extends({}, parameters, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections(_extends({}, parameters, {\n    sections\n  }));\n};","map":{"version":3,"names":["_extends","applyLocalizedDigits","cleanLeadingZeros","doesSectionFormatHaveLeadingZeros","getDateSectionConfigFromFormatToken","removeLocalizedDigits","expandFormat","_ref","utils","format","formatExpansionOverflow","prevFormat","nextFormat","Error","getEscapedPartsFromFormat","_ref2","expandedFormat","escapedParts","start","startChar","end","endChar","escapedCharacters","regExp","RegExp","match","exec","push","index","lastIndex","getSectionPlaceholder","localeText","sectionConfig","sectionFormat","type","fieldYearPlaceholder","digitAmount","formatByString","date","undefined","length","fieldMonthPlaceholder","contentType","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","createSection","_ref3","shouldRespectLeadingZeros","localizedDigits","now","token","startSeparator","hasLeadingZerosInFormat","hasLeadingZerosInInput","isValidDate","isValid","sectionValue","maxLength","value","placeholder","endSeparator","modified","buildSections","parameters","sections","validTokens","Object","keys","formatTokenMap","sort","a","b","regExpFirstWordInFormat","regExpWordOnlyComposedOfTokens","join","regExpFirstTokenInWord","getEscapedPartOfCurrentChar","i","find","escapeIndex","escapedPartOfCurrentChar","isEscapedChar","firstWordInFormat","slice","test","word","firstWord","char","isEscapeBoundary","isEndFormatSeparator","postProcessSections","_ref4","isRtl","formatDensity","map","section","cleanSeparator","separator","cleanedSeparator","includes","buildSectionsFromFormat","enableAccessibleFieldDOMStructure","split","reverse"],"sources":["/Users/ssridhar2/work/cron-scheduler-app/node_modules/@mui/x-date-pickers/esm/internals/hooks/useField/buildSectionsFromFormat.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { applyLocalizedDigits, cleanLeadingZeros, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, removeLocalizedDigits } from \"./useField.utils.js\";\nconst expandFormat = ({\n  utils,\n  format\n}) => {\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the component.');\n    }\n  }\n  return nextFormat;\n};\nconst getEscapedPartsFromFormat = ({\n  utils,\n  expandedFormat\n}) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nconst getSectionPlaceholder = (utils, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(undefined, 'default'), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nconst createSection = ({\n  utils,\n  date,\n  shouldRespectLeadingZeros,\n  localeText,\n  localizedDigits,\n  now,\n  token,\n  startSeparator\n}) => {\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n  const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = utils.isValid(date);\n  let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n  let maxLength = null;\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxLength' property on it's adapter`);\n      }\n      maxLength = sectionConfig.maxLength;\n      if (isValidDate) {\n        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n  return _extends({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\nconst buildSections = parameters => {\n  const {\n    utils,\n    expandedFormat,\n    escapedParts\n  } = parameters;\n  const now = utils.date(undefined);\n  const sections = [];\n  let startSeparator = '';\n\n  // This RegExp tests if the beginning of a string corresponds to a supported token\n  const validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n  let i = 0;\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];\n\n    // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection(_extends({}, parameters, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n      i += firstWordInFormat.length;\n    }\n    // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i];\n\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n          sections[sections.length - 1].isEndFormatSeparator = true;\n        }\n      }\n      i += 1;\n    }\n  }\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n  return sections;\n};\nconst postProcessSections = ({\n  isRtl,\n  formatDensity,\n  sections\n}) => {\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\nexport const buildSectionsFromFormat = parameters => {\n  let expandedFormat = expandFormat(parameters);\n  if (parameters.isRtl && parameters.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n  const escapedParts = getEscapedPartsFromFormat(_extends({}, parameters, {\n    expandedFormat\n  }));\n  const sections = buildSections(_extends({}, parameters, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections(_extends({}, parameters, {\n    sections\n  }));\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}